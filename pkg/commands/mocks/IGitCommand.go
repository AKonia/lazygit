// Code generated by mockery v2.8.0. DO NOT EDIT.

package mocks

import (
	exec "os/exec"

	commands "github.com/jesseduffield/lazygit/pkg/commands"

	filetree "github.com/jesseduffield/lazygit/pkg/gui/filetree"

	mock "github.com/stretchr/testify/mock"

	models "github.com/jesseduffield/lazygit/pkg/commands/models"

	oscommands "github.com/jesseduffield/lazygit/pkg/commands/oscommands"

	patch "github.com/jesseduffield/lazygit/pkg/commands/patch"
)

// IGitCommand is an autogenerated mock type for the IGitCommand type
type IGitCommand struct {
	mock.Mock
}

// AbortMerge provides a mock function with given fields:
func (_m *IGitCommand) AbortMerge() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRemote provides a mock function with given fields: name, url
func (_m *IGitCommand) AddRemote(name string, url string) error {
	ret := _m.Called(name, url)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(name, url)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AmendHead provides a mock function with given fields:
func (_m *IGitCommand) AmendHead() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AmendHeadCmdStr provides a mock function with given fields:
func (_m *IGitCommand) AmendHeadCmdStr() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AmendTo provides a mock function with given fields: sha
func (_m *IGitCommand) AmendTo(sha string) error {
	ret := _m.Called(sha)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(sha)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ApplyPatch provides a mock function with given fields: _a0, flags
func (_m *IGitCommand) ApplyPatch(_a0 string, flags ...string) error {
	_va := make([]interface{}, len(flags))
	for _i := range flags {
		_va[_i] = flags[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...string) error); ok {
		r0 = rf(_a0, flags...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BeforeAndAfterFileForRename provides a mock function with given fields: file
func (_m *IGitCommand) BeforeAndAfterFileForRename(file *models.File) (*models.File, *models.File, error) {
	ret := _m.Called(file)

	var r0 *models.File
	if rf, ok := ret.Get(0).(func(*models.File) *models.File); ok {
		r0 = rf(file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.File)
		}
	}

	var r1 *models.File
	if rf, ok := ret.Get(1).(func(*models.File) *models.File); ok {
		r1 = rf(file)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*models.File)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*models.File) error); ok {
		r2 = rf(file)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// BeginInteractiveRebaseForCommit provides a mock function with given fields: commits, commitIndex
func (_m *IGitCommand) BeginInteractiveRebaseForCommit(commits []*models.Commit, commitIndex int) error {
	ret := _m.Called(commits, commitIndex)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int) error); ok {
		r0 = rf(commits, commitIndex)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CatFile provides a mock function with given fields: fileName
func (_m *IGitCommand) CatFile(fileName string) (string, error) {
	ret := _m.Called(fileName)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(fileName)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(fileName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckRemoteBranchExists provides a mock function with given fields: branch
func (_m *IGitCommand) CheckRemoteBranchExists(branch *models.Branch) bool {
	ret := _m.Called(branch)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*models.Branch) bool); ok {
		r0 = rf(branch)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Checkout provides a mock function with given fields: branch, options
func (_m *IGitCommand) Checkout(branch string, options commands.CheckoutOptions) error {
	ret := _m.Called(branch, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, commands.CheckoutOptions) error); ok {
		r0 = rf(branch, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckoutFile provides a mock function with given fields: commitSha, fileName
func (_m *IGitCommand) CheckoutFile(commitSha string, fileName string) error {
	ret := _m.Called(commitSha, fileName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(commitSha, fileName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CherryPickCommits provides a mock function with given fields: commits
func (_m *IGitCommand) CherryPickCommits(commits []*models.Commit) error {
	ret := _m.Called(commits)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit) error); ok {
		r0 = rf(commits)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CommitCmdStr provides a mock function with given fields: message, flags
func (_m *IGitCommand) CommitCmdStr(message string, flags string) string {
	ret := _m.Called(message, flags)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(message, flags)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ConfiguredPager provides a mock function with given fields:
func (_m *IGitCommand) ConfiguredPager() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// CreateFixupCommit provides a mock function with given fields: sha
func (_m *IGitCommand) CreateFixupCommit(sha string) error {
	ret := _m.Called(sha)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(sha)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateLightweightTag provides a mock function with given fields: tagName, commitSha
func (_m *IGitCommand) CreateLightweightTag(tagName string, commitSha string) error {
	ret := _m.Called(tagName, commitSha)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(tagName, commitSha)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CurrentBranchName provides a mock function with given fields:
func (_m *IGitCommand) CurrentBranchName() (string, string, error) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func() error); ok {
		r2 = rf()
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeleteBranch provides a mock function with given fields: branch, force
func (_m *IGitCommand) DeleteBranch(branch string, force bool) error {
	ret := _m.Called(branch, force)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, bool) error); ok {
		r0 = rf(branch, force)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePatchesFromCommit provides a mock function with given fields: commits, commitIndex, p
func (_m *IGitCommand) DeletePatchesFromCommit(commits []*models.Commit, commitIndex int, p *patch.PatchManager) error {
	ret := _m.Called(commits, commitIndex, p)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, *patch.PatchManager) error); ok {
		r0 = rf(commits, commitIndex, p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRemoteBranch provides a mock function with given fields: remoteName, branchName, promptUserForCredential
func (_m *IGitCommand) DeleteRemoteBranch(remoteName string, branchName string, promptUserForCredential func(string) string) error {
	ret := _m.Called(remoteName, branchName, promptUserForCredential)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, func(string) string) error); ok {
		r0 = rf(remoteName, branchName, promptUserForCredential)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTag provides a mock function with given fields: tagName
func (_m *IGitCommand) DeleteTag(tagName string) error {
	ret := _m.Called(tagName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(tagName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DiscardAllDirChanges provides a mock function with given fields: node
func (_m *IGitCommand) DiscardAllDirChanges(node *filetree.FileNode) error {
	ret := _m.Called(node)

	var r0 error
	if rf, ok := ret.Get(0).(func(*filetree.FileNode) error); ok {
		r0 = rf(node)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DiscardAllFileChanges provides a mock function with given fields: file
func (_m *IGitCommand) DiscardAllFileChanges(file *models.File) error {
	ret := _m.Called(file)

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.File) error); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DiscardAnyUnstagedFileChanges provides a mock function with given fields:
func (_m *IGitCommand) DiscardAnyUnstagedFileChanges() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DiscardOldFileChanges provides a mock function with given fields: commits, commitIndex, fileName
func (_m *IGitCommand) DiscardOldFileChanges(commits []*models.Commit, commitIndex int, fileName string) error {
	ret := _m.Called(commits, commitIndex, fileName)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, string) error); ok {
		r0 = rf(commits, commitIndex, fileName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DiscardUnstagedDirChanges provides a mock function with given fields: node
func (_m *IGitCommand) DiscardUnstagedDirChanges(node *filetree.FileNode) error {
	ret := _m.Called(node)

	var r0 error
	if rf, ok := ret.Get(0).(func(*filetree.FileNode) error); ok {
		r0 = rf(node)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DiscardUnstagedFileChanges provides a mock function with given fields: file
func (_m *IGitCommand) DiscardUnstagedFileChanges(file *models.File) error {
	ret := _m.Called(file)

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.File) error); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EditFileCmdStr provides a mock function with given fields: filename
func (_m *IGitCommand) EditFileCmdStr(filename string) (string, error) {
	ret := _m.Called(filename)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(filename)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(filename)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EditRebaseTodo provides a mock function with given fields: index, action
func (_m *IGitCommand) EditRebaseTodo(index int, action string) error {
	ret := _m.Called(index, action)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string) error); ok {
		r0 = rf(index, action)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FastForward provides a mock function with given fields: branchName, remoteName, remoteBranchName, promptUserForCredential
func (_m *IGitCommand) FastForward(branchName string, remoteName string, remoteBranchName string, promptUserForCredential func(string) string) error {
	ret := _m.Called(branchName, remoteName, remoteBranchName, promptUserForCredential)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, func(string) string) error); ok {
		r0 = rf(branchName, remoteName, remoteBranchName, promptUserForCredential)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Fetch provides a mock function with given fields: opts
func (_m *IGitCommand) Fetch(opts commands.FetchOptions) error {
	ret := _m.Called(opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(commands.FetchOptions) error); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FetchRemote provides a mock function with given fields: remoteName, promptUserForCredential
func (_m *IGitCommand) FetchRemote(remoteName string, promptUserForCredential func(string) string) error {
	ret := _m.Called(remoteName, promptUserForCredential)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, func(string) string) error); ok {
		r0 = rf(remoteName, promptUserForCredential)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindRemoteForBranchInConfig provides a mock function with given fields: _a0
func (_m *IGitCommand) FindRemoteForBranchInConfig(_a0 string) (string, error) {
	ret := _m.Called(_a0)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateGenericRebaseTodo provides a mock function with given fields: commits, actionIndex, action
func (_m *IGitCommand) GenerateGenericRebaseTodo(commits []*models.Commit, actionIndex int, action string) (string, string, error) {
	ret := _m.Called(commits, actionIndex, action)

	var r0 string
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, string) string); ok {
		r0 = rf(commits, actionIndex, action)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func([]*models.Commit, int, string) string); ok {
		r1 = rf(commits, actionIndex, action)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func([]*models.Commit, int, string) error); ok {
		r2 = rf(commits, actionIndex, action)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GenericMergeOrRebaseAction provides a mock function with given fields: commandType, command
func (_m *IGitCommand) GenericMergeOrRebaseAction(commandType string, command string) error {
	ret := _m.Called(commandType, command)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(commandType, command)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBranchGraph provides a mock function with given fields: branchName
func (_m *IGitCommand) GetBranchGraph(branchName string) (string, error) {
	ret := _m.Called(branchName)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(branchName)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(branchName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBranchGraphCmdStr provides a mock function with given fields: branchName
func (_m *IGitCommand) GetBranchGraphCmdStr(branchName string) string {
	ret := _m.Called(branchName)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(branchName)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetBranchUpstreamDifferenceCount provides a mock function with given fields: branchName
func (_m *IGitCommand) GetBranchUpstreamDifferenceCount(branchName string) (string, string) {
	ret := _m.Called(branchName)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(branchName)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string) string); ok {
		r1 = rf(branchName)
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GetCommitDifferences provides a mock function with given fields: from, to
func (_m *IGitCommand) GetCommitDifferences(from string, to string) (string, string) {
	ret := _m.Called(from, to)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(from, to)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string) string); ok {
		r1 = rf(from, to)
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GetCommitMessage provides a mock function with given fields: commitSha
func (_m *IGitCommand) GetCommitMessage(commitSha string) (string, error) {
	ret := _m.Called(commitSha)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(commitSha)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(commitSha)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitMessageFirstLine provides a mock function with given fields: sha
func (_m *IGitCommand) GetCommitMessageFirstLine(sha string) (string, error) {
	ret := _m.Called(sha)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(sha)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(sha)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigValue provides a mock function with given fields: key
func (_m *IGitCommand) GetConfigValue(key string) string {
	ret := _m.Called(key)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetCurrentBranchUpstreamDifferenceCount provides a mock function with given fields:
func (_m *IGitCommand) GetCurrentBranchUpstreamDifferenceCount() (string, string) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GetFilesInDiff provides a mock function with given fields: from, to, reverse
func (_m *IGitCommand) GetFilesInDiff(from string, to string, reverse bool) ([]*models.CommitFile, error) {
	ret := _m.Called(from, to, reverse)

	var r0 []*models.CommitFile
	if rf, ok := ret.Get(0).(func(string, string, bool) []*models.CommitFile); ok {
		r0 = rf(from, to, reverse)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.CommitFile)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, bool) error); ok {
		r1 = rf(from, to, reverse)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHeadCommitMessage provides a mock function with given fields:
func (_m *IGitCommand) GetHeadCommitMessage() (string, error) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPager provides a mock function with given fields: width
func (_m *IGitCommand) GetPager(width int) string {
	ret := _m.Called(width)

	var r0 string
	if rf, ok := ret.Get(0).(func(int) string); ok {
		r0 = rf(width)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetPushToCurrent provides a mock function with given fields:
func (_m *IGitCommand) GetPushToCurrent() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetReflogCommits provides a mock function with given fields: lastReflogCommit, filterPath
func (_m *IGitCommand) GetReflogCommits(lastReflogCommit *models.Commit, filterPath string) ([]*models.Commit, bool, error) {
	ret := _m.Called(lastReflogCommit, filterPath)

	var r0 []*models.Commit
	if rf, ok := ret.Get(0).(func(*models.Commit, string) []*models.Commit); ok {
		r0 = rf(lastReflogCommit, filterPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Commit)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(*models.Commit, string) bool); ok {
		r1 = rf(lastReflogCommit, filterPath)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*models.Commit, string) error); ok {
		r2 = rf(lastReflogCommit, filterPath)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetRemoteURL provides a mock function with given fields:
func (_m *IGitCommand) GetRemoteURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetRemotes provides a mock function with given fields:
func (_m *IGitCommand) GetRemotes() ([]*models.Remote, error) {
	ret := _m.Called()

	var r0 []*models.Remote
	if rf, ok := ret.Get(0).(func() []*models.Remote); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Remote)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStashEntries provides a mock function with given fields: filterPath
func (_m *IGitCommand) GetStashEntries(filterPath string) []*models.StashEntry {
	ret := _m.Called(filterPath)

	var r0 []*models.StashEntry
	if rf, ok := ret.Get(0).(func(string) []*models.StashEntry); ok {
		r0 = rf(filterPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.StashEntry)
		}
	}

	return r0
}

// GetStatusFiles provides a mock function with given fields: opts
func (_m *IGitCommand) GetStatusFiles(opts commands.GetStatusFileOptions) []*models.File {
	ret := _m.Called(opts)

	var r0 []*models.File
	if rf, ok := ret.Get(0).(func(commands.GetStatusFileOptions) []*models.File); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.File)
		}
	}

	return r0
}

// GetSubmoduleConfigs provides a mock function with given fields:
func (_m *IGitCommand) GetSubmoduleConfigs() ([]*models.SubmoduleConfig, error) {
	ret := _m.Called()

	var r0 []*models.SubmoduleConfig
	if rf, ok := ret.Get(0).(func() []*models.SubmoduleConfig); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.SubmoduleConfig)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTags provides a mock function with given fields:
func (_m *IGitCommand) GetTags() ([]*models.Tag, error) {
	ret := _m.Called()

	var r0 []*models.Tag
	if rf, ok := ret.Get(0).(func() []*models.Tag); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Tag)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUpstreamForBranch provides a mock function with given fields: branchName
func (_m *IGitCommand) GetUpstreamForBranch(branchName string) (string, error) {
	ret := _m.Called(branchName)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(branchName)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(branchName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GitStatus provides a mock function with given fields: opts
func (_m *IGitCommand) GitStatus(opts commands.GitStatusOptions) (string, error) {
	ret := _m.Called(opts)

	var r0 string
	if rf, ok := ret.Get(0).(func(commands.GitStatusOptions) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(commands.GitStatusOptions) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ignore provides a mock function with given fields: filename
func (_m *IGitCommand) Ignore(filename string) error {
	ret := _m.Called(filename)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(filename)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InteractiveRebase provides a mock function with given fields: commits, index, action
func (_m *IGitCommand) InteractiveRebase(commits []*models.Commit, index int, action string) error {
	ret := _m.Called(commits, index, action)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, string) error); ok {
		r0 = rf(commits, index, action)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsBareRepo provides a mock function with given fields:
func (_m *IGitCommand) IsBareRepo() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsHeadDetached provides a mock function with given fields:
func (_m *IGitCommand) IsHeadDetached() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsInMergeState provides a mock function with given fields:
func (_m *IGitCommand) IsInMergeState() (bool, error) {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Merge provides a mock function with given fields: branchName, opts
func (_m *IGitCommand) Merge(branchName string, opts commands.MergeOpts) error {
	ret := _m.Called(branchName, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, commands.MergeOpts) error); ok {
		r0 = rf(branchName, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MoveCommitDown provides a mock function with given fields: commits, index
func (_m *IGitCommand) MoveCommitDown(commits []*models.Commit, index int) error {
	ret := _m.Called(commits, index)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int) error); ok {
		r0 = rf(commits, index)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MovePatchIntoIndex provides a mock function with given fields: commits, commitIdx, p, stash
func (_m *IGitCommand) MovePatchIntoIndex(commits []*models.Commit, commitIdx int, p *patch.PatchManager, stash bool) error {
	ret := _m.Called(commits, commitIdx, p, stash)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, *patch.PatchManager, bool) error); ok {
		r0 = rf(commits, commitIdx, p, stash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MovePatchToSelectedCommit provides a mock function with given fields: commits, sourceCommitIdx, destinationCommitIdx, p
func (_m *IGitCommand) MovePatchToSelectedCommit(commits []*models.Commit, sourceCommitIdx int, destinationCommitIdx int, p *patch.PatchManager) error {
	ret := _m.Called(commits, sourceCommitIdx, destinationCommitIdx, p)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, int, *patch.PatchManager) error); ok {
		r0 = rf(commits, sourceCommitIdx, destinationCommitIdx, p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MoveTodoDown provides a mock function with given fields: index
func (_m *IGitCommand) MoveTodoDown(index int) error {
	ret := _m.Called(index)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewBranch provides a mock function with given fields: name, base
func (_m *IGitCommand) NewBranch(name string, base string) error {
	ret := _m.Called(name, base)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(name, base)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OpenMergeTool provides a mock function with given fields:
func (_m *IGitCommand) OpenMergeTool() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// OpenMergeToolCmd provides a mock function with given fields:
func (_m *IGitCommand) OpenMergeToolCmd() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PrepareInteractiveRebaseCommand provides a mock function with given fields: baseSha, todo, overrideEditor
func (_m *IGitCommand) PrepareInteractiveRebaseCommand(baseSha string, todo string, overrideEditor bool) (*exec.Cmd, error) {
	ret := _m.Called(baseSha, todo, overrideEditor)

	var r0 *exec.Cmd
	if rf, ok := ret.Get(0).(func(string, string, bool) *exec.Cmd); ok {
		r0 = rf(baseSha, todo, overrideEditor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*exec.Cmd)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, bool) error); ok {
		r1 = rf(baseSha, todo, overrideEditor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PullPatchIntoNewCommit provides a mock function with given fields: commits, commitIdx, p
func (_m *IGitCommand) PullPatchIntoNewCommit(commits []*models.Commit, commitIdx int, p *patch.PatchManager) error {
	ret := _m.Called(commits, commitIdx, p)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.Commit, int, *patch.PatchManager) error); ok {
		r0 = rf(commits, commitIdx, p)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Push provides a mock function with given fields: branchName, force, upstream, args, promptUserForCredential
func (_m *IGitCommand) Push(branchName string, force bool, upstream string, args string, promptUserForCredential func(string) string) error {
	ret := _m.Called(branchName, force, upstream, args, promptUserForCredential)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, bool, string, string, func(string) string) error); ok {
		r0 = rf(branchName, force, upstream, args, promptUserForCredential)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PushTag provides a mock function with given fields: remoteName, tagName, promptUserForCredential
func (_m *IGitCommand) PushTag(remoteName string, tagName string, promptUserForCredential func(string) string) error {
	ret := _m.Called(remoteName, tagName, promptUserForCredential)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, func(string) string) error); ok {
		r0 = rf(remoteName, tagName, promptUserForCredential)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RebaseBranch provides a mock function with given fields: branchName
func (_m *IGitCommand) RebaseBranch(branchName string) error {
	ret := _m.Called(branchName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(branchName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RebaseMode provides a mock function with given fields:
func (_m *IGitCommand) RebaseMode() (string, error) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveRemote provides a mock function with given fields: name
func (_m *IGitCommand) RemoveRemote(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveTrackedFiles provides a mock function with given fields: name
func (_m *IGitCommand) RemoveTrackedFiles(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveUntrackedDirFiles provides a mock function with given fields: node
func (_m *IGitCommand) RemoveUntrackedDirFiles(node *filetree.FileNode) error {
	ret := _m.Called(node)

	var r0 error
	if rf, ok := ret.Get(0).(func(*filetree.FileNode) error); ok {
		r0 = rf(node)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveUntrackedFiles provides a mock function with given fields:
func (_m *IGitCommand) RemoveUntrackedFiles() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RenameBranch provides a mock function with given fields: oldName, newName
func (_m *IGitCommand) RenameBranch(oldName string, newName string) error {
	ret := _m.Called(oldName, newName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(oldName, newName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RenameCommit provides a mock function with given fields: name
func (_m *IGitCommand) RenameCommit(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RenameRemote provides a mock function with given fields: oldRemoteName, newRemoteName
func (_m *IGitCommand) RenameRemote(oldRemoteName string, newRemoteName string) error {
	ret := _m.Called(oldRemoteName, newRemoteName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(oldRemoteName, newRemoteName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResetAndClean provides a mock function with given fields:
func (_m *IGitCommand) ResetAndClean() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResetHard provides a mock function with given fields: ref
func (_m *IGitCommand) ResetHard(ref string) error {
	ret := _m.Called(ref)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(ref)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResetMixed provides a mock function with given fields: ref
func (_m *IGitCommand) ResetMixed(ref string) error {
	ret := _m.Called(ref)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(ref)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResetSoft provides a mock function with given fields: ref
func (_m *IGitCommand) ResetSoft(ref string) error {
	ret := _m.Called(ref)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(ref)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResetSubmodules provides a mock function with given fields: submodules
func (_m *IGitCommand) ResetSubmodules(submodules []*models.SubmoduleConfig) error {
	ret := _m.Called(submodules)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*models.SubmoduleConfig) error); ok {
		r0 = rf(submodules)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResetToCommit provides a mock function with given fields: sha, strength, options
func (_m *IGitCommand) ResetToCommit(sha string, strength string, options oscommands.RunCommandOptions) error {
	ret := _m.Called(sha, strength, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, oscommands.RunCommandOptions) error); ok {
		r0 = rf(sha, strength, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Revert provides a mock function with given fields: sha
func (_m *IGitCommand) Revert(sha string) error {
	ret := _m.Called(sha)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(sha)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RevertMerge provides a mock function with given fields: sha, parentNumber
func (_m *IGitCommand) RevertMerge(sha string, parentNumber int) error {
	ret := _m.Called(sha, parentNumber)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = rf(sha, parentNumber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RewordCommit provides a mock function with given fields: commits, index
func (_m *IGitCommand) RewordCommit(commits []*models.Commit, index int) (*exec.Cmd, error) {
	ret := _m.Called(commits, index)

	var r0 *exec.Cmd
	if rf, ok := ret.Get(0).(func([]*models.Commit, int) *exec.Cmd); ok {
		r0 = rf(commits, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*exec.Cmd)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]*models.Commit, int) error); ok {
		r1 = rf(commits, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunCommand provides a mock function with given fields: formatString, formatArgs
func (_m *IGitCommand) RunCommand(formatString string, formatArgs ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, formatString)
	_ca = append(_ca, formatArgs...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) error); ok {
		r0 = rf(formatString, formatArgs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunCommandWithOutput provides a mock function with given fields: formatString, formatArgs
func (_m *IGitCommand) RunCommandWithOutput(formatString string, formatArgs ...interface{}) (string, error) {
	var _ca []interface{}
	_ca = append(_ca, formatString)
	_ca = append(_ca, formatArgs...)
	ret := _m.Called(_ca...)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, ...interface{}) string); ok {
		r0 = rf(formatString, formatArgs...)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(formatString, formatArgs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetBranchUpstream provides a mock function with given fields: remoteName, remoteBranchName, branchName
func (_m *IGitCommand) SetBranchUpstream(remoteName string, remoteBranchName string, branchName string) error {
	ret := _m.Called(remoteName, remoteBranchName, branchName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(remoteName, remoteBranchName, branchName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetUpstreamBranch provides a mock function with given fields: upstream
func (_m *IGitCommand) SetUpstreamBranch(upstream string) error {
	ret := _m.Called(upstream)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(upstream)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ShowCmdStr provides a mock function with given fields: sha, filterPath
func (_m *IGitCommand) ShowCmdStr(sha string, filterPath string) string {
	ret := _m.Called(sha, filterPath)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(sha, filterPath)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ShowFileDiff provides a mock function with given fields: from, to, reverse, fileName, plain
func (_m *IGitCommand) ShowFileDiff(from string, to string, reverse bool, fileName string, plain bool) (string, error) {
	ret := _m.Called(from, to, reverse, fileName, plain)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, bool, string, bool) string); ok {
		r0 = rf(from, to, reverse, fileName, plain)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, bool, string, bool) error); ok {
		r1 = rf(from, to, reverse, fileName, plain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShowFileDiffCmdStr provides a mock function with given fields: from, to, reverse, fileName, plain
func (_m *IGitCommand) ShowFileDiffCmdStr(from string, to string, reverse bool, fileName string, plain bool) string {
	ret := _m.Called(from, to, reverse, fileName, plain)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, bool, string, bool) string); ok {
		r0 = rf(from, to, reverse, fileName, plain)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ShowStashEntryCmdStr provides a mock function with given fields: index
func (_m *IGitCommand) ShowStashEntryCmdStr(index int) string {
	ret := _m.Called(index)

	var r0 string
	if rf, ok := ret.Get(0).(func(int) string); ok {
		r0 = rf(index)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SquashAllAboveFixupCommits provides a mock function with given fields: sha
func (_m *IGitCommand) SquashAllAboveFixupCommits(sha string) error {
	ret := _m.Called(sha)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(sha)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StageAll provides a mock function with given fields:
func (_m *IGitCommand) StageAll() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StageFile provides a mock function with given fields: fileName
func (_m *IGitCommand) StageFile(fileName string) error {
	ret := _m.Called(fileName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(fileName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StashDo provides a mock function with given fields: index, method
func (_m *IGitCommand) StashDo(index int, method string) error {
	ret := _m.Called(index, method)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string) error); ok {
		r0 = rf(index, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StashSave provides a mock function with given fields: message
func (_m *IGitCommand) StashSave(message string) error {
	ret := _m.Called(message)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StashSaveStagedChanges provides a mock function with given fields: message
func (_m *IGitCommand) StashSaveStagedChanges(message string) error {
	ret := _m.Called(message)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleAdd provides a mock function with given fields: name, path, url
func (_m *IGitCommand) SubmoduleAdd(name string, path string, url string) error {
	ret := _m.Called(name, path, url)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(name, path, url)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleBulkDeinitCmdStr provides a mock function with given fields:
func (_m *IGitCommand) SubmoduleBulkDeinitCmdStr() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SubmoduleBulkInitCmdStr provides a mock function with given fields:
func (_m *IGitCommand) SubmoduleBulkInitCmdStr() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SubmoduleBulkUpdateCmdStr provides a mock function with given fields:
func (_m *IGitCommand) SubmoduleBulkUpdateCmdStr() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SubmoduleDelete provides a mock function with given fields: submodule
func (_m *IGitCommand) SubmoduleDelete(submodule *models.SubmoduleConfig) error {
	ret := _m.Called(submodule)

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.SubmoduleConfig) error); ok {
		r0 = rf(submodule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleForceBulkUpdateCmdStr provides a mock function with given fields:
func (_m *IGitCommand) SubmoduleForceBulkUpdateCmdStr() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SubmoduleInit provides a mock function with given fields: path
func (_m *IGitCommand) SubmoduleInit(path string) error {
	ret := _m.Called(path)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleReset provides a mock function with given fields: submodule
func (_m *IGitCommand) SubmoduleReset(submodule *models.SubmoduleConfig) error {
	ret := _m.Called(submodule)

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.SubmoduleConfig) error); ok {
		r0 = rf(submodule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleStash provides a mock function with given fields: submodule
func (_m *IGitCommand) SubmoduleStash(submodule *models.SubmoduleConfig) error {
	ret := _m.Called(submodule)

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.SubmoduleConfig) error); ok {
		r0 = rf(submodule)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleUpdate provides a mock function with given fields: path
func (_m *IGitCommand) SubmoduleUpdate(path string) error {
	ret := _m.Called(path)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleUpdateAll provides a mock function with given fields:
func (_m *IGitCommand) SubmoduleUpdateAll() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmoduleUpdateUrl provides a mock function with given fields: name, path, newUrl
func (_m *IGitCommand) SubmoduleUpdateUrl(name string, path string, newUrl string) error {
	ret := _m.Called(name, path, newUrl)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(name, path, newUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnStageFile provides a mock function with given fields: fileNames, reset
func (_m *IGitCommand) UnStageFile(fileNames []string, reset bool) error {
	ret := _m.Called(fileNames, reset)

	var r0 error
	if rf, ok := ret.Get(0).(func([]string, bool) error); ok {
		r0 = rf(fileNames, reset)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnstageAll provides a mock function with given fields:
func (_m *IGitCommand) UnstageAll() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRemoteUrl provides a mock function with given fields: remoteName, updatedUrl
func (_m *IGitCommand) UpdateRemoteUrl(remoteName string, updatedUrl string) error {
	ret := _m.Called(remoteName, updatedUrl)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(remoteName, updatedUrl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsingGpg provides a mock function with given fields:
func (_m *IGitCommand) UsingGpg() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// WithSpan provides a mock function with given fields: span
func (_m *IGitCommand) WithSpan(span string) *commands.GitCommand {
	ret := _m.Called(span)

	var r0 *commands.GitCommand
	if rf, ok := ret.Get(0).(func(string) *commands.GitCommand); ok {
		r0 = rf(span)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commands.GitCommand)
		}
	}

	return r0
}

// WorkingTreeState provides a mock function with given fields:
func (_m *IGitCommand) WorkingTreeState() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// WorktreeFileDiff provides a mock function with given fields: file, plain, cached
func (_m *IGitCommand) WorktreeFileDiff(file *models.File, plain bool, cached bool) string {
	ret := _m.Called(file, plain, cached)

	var r0 string
	if rf, ok := ret.Get(0).(func(*models.File, bool, bool) string); ok {
		r0 = rf(file, plain, cached)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// WorktreeFileDiffCmdStr provides a mock function with given fields: node, plain, cached
func (_m *IGitCommand) WorktreeFileDiffCmdStr(node models.IFile, plain bool, cached bool) string {
	ret := _m.Called(node, plain, cached)

	var r0 string
	if rf, ok := ret.Get(0).(func(models.IFile, bool, bool) string); ok {
		r0 = rf(node, plain, cached)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}
